## 데이터 모델링이란 ?
> 데이터 모델링은 '현실 세계'를 단순화하여 표현하는 기법

## 데이터 모델링 특징 및 목적
### 특징
- **추상화** : 현실세계, 개념을 **일정한 형식**으로 **'간략하게'** 표현

- **단순화** : 현실세계를 '**정해진 표기법**'으로 **단순하고 쉽게 표현**, 핵심에 집중 + **불필요 제거**

- **명확화** : 불분명함(**애매모호함**)을 제거하고, **'정확하게' 현상을 기술**

### 목적
- 단순히 DB, 시스템 만을 구축하기 위한 것이 아닌 업무 설명, 분석, 형상화 목적도 있음

## 데이터 모델링 유의점 및 3가지 관점 및 중요 3요소
### 유의점
- 중복(Duplication) : 같은 데이터가 엔티티에 중복 저장되면 안된다.

- 비유연성(Inflexibility) : 애플리케이션의 '사소한 변경'에도 데이터 모델이 수시로 변경되면 안된다.
    - 데이터 모델과 프로세스 분리해서 유연성 높여야한다.

- 비일관성(Inconsistency) : 중복이 없는 경우에도 비일관성 발생 가능성 있음
    - 데이터 간의 연관 관계에 대해 명확하게 정의

### 관점
- 데이터 관점 (What, Data)
    - 어떤 데이터들이 업무와 얽혀있는지

- 프로세스 관점 (How, Process)
    - 업무가 실제로 처리하고 있는 일이 무엇인지

- 데이터와 프로세스의 상관 관 (Data vs Process, Intercation)
    - 프로세스 흐름에 따라 데이터가 어떤 영향을 받는지

### 중요 요소
- Things : 대상(Entity)
- Attribute : 속성
- Relationships : 관계

## 모델링의 3가지 단계
1. 개념적 데이터 모델링

    : '전사적'으로 수행, 업무 중심적이고 포괄적인 수준의 모델링(추상화 레벨 가장 높음)

2. 논리적 데이터 모델링

    : Key, 속성, 관계들을 표현하는 단계 -> 정규화 활동이 이루어지는 단계
    
    : 논리적데이터모델을 대상으로 정규화 하는 것

3. 물리적 데이터 모델링

    : 실제 DB를 구현할 수 있도록 성능, 가용성 등 물리적 요소를 고려하는 단계

## 데이터 스키마 단계에 따른 독립성
### 스키마란 ?
- 테이블이 어떠한 구성으로 되어있는지, 어떤 정보를 가지고 있는지에 대한기본적인 테이블의 구조를 정의한 것

### 데이터 스키마의 구조
#### User
- 외부 스키마 : 각(여러) 사용자가 보는 스키마 정의 및 표현

- 개념 스키마 : 모든(여러 X) 사용자가 보는 데이터 정의 및 표현 & 관계를 정의하는 단계

- 내부 스키마 : 물리적인 저장 구조를 나타내는 단계 -> 저장 구조, 칼럼, 인덱스 정의

#### DB
- 논리적 독립성 : 개념 스키마가 변경되어도 외부 스키마는 영향 X, 외부 - 개념

- 물리적 독립성 : 내부 스키마가 변경되어도 개념 / 외부 스키마는 영향 X, 외부, 개념 - 내부

## ERD 작성 순서
1. 엔티티 도출
2. 엔티티 배치
3. 엔티티 관계 설정
    - 기본 키로 속성이 상속되는 식별자 관계를 설정
    - 중복되는 관계가 있으면 안된다.
    - Circle 관계가 발생하면 안된다.
4. 관계명 기입
    - 현재형을 사용한다.
    - 지나치게 포괄적인 용어는 사용하지 않는다.
    - IE/Crow's 표기법에서는 링크마다 각각의 관계를 기술한다.
5. 관계 참여도 기입
6. 관계 필수 / 선택 여부 기입

<img width="640" alt="img1 daumcdn" src="https://github.com/xoxlo/SQLD/assets/46445480/28a161cf-30a6-45fa-95ad-0fe248bdc970">

## 엔티티란 ?
- 업무에서 쓰이는 데이터들을 용도 별로 분류한 데이터의 그룹 = 엔티티

### 엔티티의 특징
- 업무에서 쓰이는 정보여야함
- 식별자가 있어야함
- 2개 이상의 인스턴스 가져야함
- 반드시 속성 가져야함 -> 이때 하나의 인스턴스는 2개 이상의 속성을 가짐

    -> 즉 하나의 엔티니는 2개 이상의 속성을 가짐
- 다른 엔티티와 1개 이상의 관계

## 엔티티 분류 방법과 그에 따른 종류
### 유형, 무형에 따른 분류 -> 개사유 ~ 계셔유
- 유형 엔티티 : 모델링 대상이 물리적인 형태가 존재 ex) 상품, 회원
- 개념 엔티티 : 모델링 대상이 형태 없음 ex) 부서, 학과
- 사건 엔티티 : 모델링 대상이 행위로 인해 발생하는 것 ex) 주문, 이벤트 응모
### 발생 시점에 따른 분류 -> 행기중 !
- 기본 엔티티

    : 모델링 대상이 업무에 대해 원래 존재하는 요소 -> 독립적, 자식 엔티티 가질 수 있음
    
    ex) 상품, 회원, 부서

- 중심 엔티티

    : 모델링 대상의 업무 과정 중 하나, 기본 엔티티로부터 파생, 행위 엔티티 생성
    
    ex) 주문, 매출, 계약

- 행위 엔티티

    : 2개 이상의 엔티티로부터 파생

    ex) 주문 내역, 이벤트 응모 이력 등

## 엔티티 명명 주의점
- 업무에서 실제 쓰이는 용어 사용
- 한글 약어 사용 X, 영어 대문자로 표시
- 단수 명사로 표현, 띄어쓰기 X
- 의미상 중복 X (주문, 결제 엔티티는 중복 가능)
- 명확하게 표현

## 속성이란 ?
- 엔티티의 특징을 나타내는 최소의 데이터 단위
### 속성의 특징
- 더 이상 쪼개지지 않는 레벨
- 업무에서 필요로 하는 항목
- 엔티티를 설명, 인스턴스를 설명
- 하나의 속성은 하나의 속성값만 가짐 -> 여러개 가지먼 1차 정규화
- 일반 속성은 정해진 주식별자에 함수적, 종속성 가져야한다

    -> 완전 함수적 종속이 아닌 부분 종속이면 2차 정규화 해준다

    ex) PK가 2개의 속성으로 이루어져 있는데 {속성1, 속성2}에서 속성2에만 종속성 가지면 2차 정규화로 엔티티 추가 생성해서 각 엔티티마다 완전 함수적 종속을 충족 시켜줌

## 속성의 특성에 따른 분류
### 일반적인 특성에 따른 분류
- 기본 속성

    : 업무 프로세스(기본 틀) 분석했더니 바로 정의 가능한 속성

- 설계 속성 - 인스턴스에 유니크함을 부여하는 속성(PK의 토대)

    : 업무엔 없으나, 모델링 하다보니 고유함 보전하기 위해 필요해져서 만들어짐

    ex) 학번, 사번 등등

- 파생 속성 -> 그냥 파생 들어가면 다 성능, 편의 위해 새로 만든 엔티티의 속성

    : 데이터를 조회할 때 빠른 성능 낼 수 있도록 원래 속성값을 계산하여 저장할 수 있도록 하는 속성

    ex) 평균, 재고 등등 ...
    
    -> 데이터 정합성 고려 & 가급적 적게 정의

### 구성 방식( 각 속성 및 엔티티와의 관계)에 따른 분류
- PK 속성

    : 인스턴스의 유니크함을 부여하는 속성, 일반 속성들의 종속성을 가진 키

    (기본키, 주식별자 키) #으로 표현 ex)학번, 사번

- FK 속성

    : 다른 엔티티에서 가져온 속성(외래키), 다른 엔티티와의 관계를 맺게 해줌

    -> 주식별자에 있는 속성이 FK가 될 수 있음 ex) #사원번호(FK)
    
    ex) 학과 코드, 회원 등급 코드, 부서 코드 -> 학과에 따른 엔티티가 있겠지 ? 걔랑 연결

- 일반 속성 : PK, FK를 제외한 나머지 속성

### 속성의 분해 가능 여부에 따른 분류
- 단일 속성 : 속성이 하나의 의미로 구성
- 복합 속성 : 여러 개의 의미로 구성(주소 = 시 + 구 + 동)
- 다중값 속성 : 속성이 여러 개 값 가짐 -> 1차 정규화 or 별도 엔티티 생성

## 속성이 만들어낸 데이터 모델의 개념
- 도메인

    : 속성이 가질 수 있는 속성 값의 범위

- 용어 사전

    : 속성의 이름을 정확, 직관적으로 부여하기 위한 용어 사전

- 시스템 카탈로그

    : 시스템 자체에 관련있는 데이터를 가진 DB

    : 시스템 테이블로 구성 & SQL로 조회 가능

    : 여기 저장된 데이터 = 메타 데이터, SELECT만 가능, INSERT, UPDATE 등등 불가능

## 관계란 ?
- 엔티티와 엔티티 사이에 속성끼리의 연결에 의해 만들어지는 상관 관계

### 종류
- 존재 관계 : 모델링 된 엔티티들이 존재로서 관계를 가짐
- 행위 관계 : 모델링 된 엔티티들이 행위에 의해 관계를 가짐

### UML의 클래스 다이어그램에 의해 나뉘는 종류
- 연관 관계

    : 필수적 관계(존재적 관계, 식별자 관계) - 항상 서로 이용(실선)

    : 멤버 변수로 선언

- 의존 관계

    : 선택적 관계(비식별자 관계) - 상대 클래스 행위에 따라 이용(점선)

    : 행위 코드 오퍼레이션에서 파라미터로 사용

## 관계 표기 방법(ERD)에 따른 특성 분류
- 관계명

    : 관계 이름은 시작 엔티티 - 능동적 / 끝 엔티티 - 수동적 '동사' 사용

- 관계 차수

    : 각 엔티티 끼리의 관계에 참여하는 '속성의 수' 1:1, 1:M, M:N 형식으로 구분

- 관계 선택 사양

    : 필수적 관계(엔티티끼리 항상 관계), 선택적 관계(행위에 의해 관계 여부가 성립)

        ex) 한 수업 엔티티에 참여 엔티티, 과제 인티티가 있으면
        참여는 수업이 있을 때 마다 항상 관계가 성립되어서 조회가 되지만
        과제는 과제가 있는 날에만 관계를 맺고 조회가 되기 때문에 이러한걸 구분

## 관계 체크 사항(두 엔티티 사이 관계 정의 시 유의할 사항)
- 두 엔티티 사이 관심있는 연관 규칙이 존재하는가
- 두 엔티티 사이 정보의 조합이 발생하는가
- 업무 기술 시, 장표의 관계 연결을 가능하게하는 동사가 있는가
- 업무 기술 시, 장표의 관계 연결을 가능하게하는 규칙이 서술 되어 있는가

## 식별자란 ? 주 식별자의 특성
- 각가의 인스턴스를 구분 가능하게 만들어주는 대표 속성을 뜻한다.

### 주 식별자란 ? 주 식별자의 특성 #으로 표현
: 주 식별자는 PK(Primary Key)에 해당 하는 속성 -> PK는 여러 개 존재할 수 있음

- 유일성 : 해당 속성이 인스턴스를 유일하게 식별할 수 있는 성질을 가졌는지
- 최소성 : 최소한의 속성들로만 유일성을 보장하게 하는지
- 불변성 : 속성값이 변하지 않아야함
- 존재성 : 속성값은 NULL이 될 수 없음

    -> ex) 유일성과 최소성을 만족하는 속성은 보조키로서 존재할 수 있다.

    -> 즉 특정 특성을 만족함에 따라 속성은 특정 키로서 존재 가능

## 식별자의 특성과 특정 여부에 따른 분류
### 대표성 여부
- 주 식별자(PK) - # 으로 표현
    : 유일성, 최소성, 불변성, 존재성을 모두 만족하는 식별자

    -> PK는 여러 속성이 존재할 수 있으나, 여러 속성이 존재 할 경우 나머지 일반 속성들이 해당 PK들 속성들에 대해 함수적 종속성을 띄어야함 -> 그렇지 않으면 2차 정규화하여 부분 종속에 해당하는 속성들만 따로 추가 엔티티를 생성한다
        
    - 주 식별자 도출 기준
        - 해당 업무에서 자주 이용되는 속성
        - 명칭, 내역 등의 이름은 피함
        - 속성 수를 최대한 적게 구성
        - 자주 변하지 않는 값

- 보조 식별자
    
    : 인스턴스 식별은 가능하나 엔티티를 대표하는 식별자는 아님
    
    -> 즉 다른 엔티티와의 참조 관계로 연결되지 않는다

    ex) 회원 엔티티에서

    #회원번호

    *회원명

    *아이디

    -> 에서 아이디는 다른 인스턴스랑 중복될 수 없기 때문에 해당 엔티티에서 인스턴스를 구분짓게 할 수 있는 식별자이나

    -> 이게 엔티티를 대표하지는 못함

### 스스로 생성 되었는가에 대한 여부
- 내부 식별자

    : 다른 엔티티 참조 없이 해당 엔티티 내부에서 스스로 생성된 식별자

- 외부 식별자

    : 다른 엔티티에서 온 식별자 - 다른 엔티티와 연결고리 역할

    -> 만약 부모 엔티티의 FK를 받아서 이를 주 식별자로 사용하면

    -> 해당 자식 엔티티의 PK는 SQL 조인에서 반드시 사용되고 WHERE 절에서 사용 가능성이 높음

### 단일 속성인지에 대한 여부(주 식별자 구성이 여러 속성인가)
- 단일 식별자 : 주 식별자가 1개의 속성으로 구성
- 복합 식별자 : 주 식별자가 2개 이상의 속성으로 구성

    -> 주 식별자가 2개 이상이면 해당 속성들의 우선순위를 잘 매겨서 잘 복합시킨 후 일반 속성들에게 종속시켜야 주 식별자로서 기능을 다 하게 된다.

### 대체되었는지 기존에 있는지에 대한 분류
- 원조(본질) 식별자 : 업무에 의해 만들어지는 식별자, 가공되지 않은 원래 식별자

- 인조(대리) 식별자 : 인위적으로 만들어지는 식별자, 주 식별자가 복잡할 때 이를 통합

    -> ex) 주문번호 - 대표적 인조, 대리 식별자

    -> 기존 : 사번 + 주문일자 + 순번을 주 식별자로 두고 주문을 처리하다가

    -> 이를 '주문번호'라는 단일 속성의 주 식별자로 만들면 이게 인조, 대리 식별자가 됨

## 식별자 관계 vs 비식별자 관계
### 식별자 관계
-> 트랜잭션에 의한 관계 - 동시에 커밋, 롤백 - 하나의 커밋 단위로 엔티티들이 묶임

: 부모 엔티티의 식별자 속성이 자식 엔티티의 주 식별자가 되는 관계

- 강한 연결 관계
- 실선(항시 연결)
- 부모 - 자식 관계가 항시 유지
- SQL문의 조인을 최소화 해줌

### 비식별자 관계
: 부모 엔티티의 식별자 속성이 자식 엔티티의 일반 속성이 되는 관계

- 약한 연결 관계
- 점선(선택적 연결)
- 부모 - 자식 관계가 유지 안될 수 있음

    -> 일반 속성 값은 NULL이 들어갈 수 있기 때문에 부모 엔티티의 식별자 속성에 값이 없을 때 자식 엔티티의 속성 값(인스턴스)이 생성 가능하다
