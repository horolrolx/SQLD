# 데이터 모델과 SQL
## 성능 데이터 모델링의 개요
1. 성능 데이터 모델링의 정의
    - 성능 저하의 원인 중 하나는 데이터 모델링의 근본적인 디자인이 잘못되어 있는 경우도 많다.
    - 따라서 성능 데이터 모델링을 통해 성능향상을 도모해야한다.
    - 성능 모델링 이란 ?
        - 데이터베이스 성능향상을 목적으로 설계단계의 데이터 모델링 때부터 성능과 관련된 사항이 모델링에 반영될 수 있도록 하는 것
2. 성능 데이터 모델링 수행시점
    - 사전에 성능 모델링을 할수록 성능 향상을 위한 비용은 적게 든다.
    - 분석 / 설계 단계에서 성능을 고려해 데이터 모델링을 수행할 경우 재업무 비용을 최소화 할 수 있다.
    - 따라서 분석 / 설계 단계에서 처리 성능을 향상시킬 방법을 고려해야한다

3. 성능 데이터 모델링 고려사항
    - 성능 데이터 모델링 프로세스
        - 정규화 -> 정규화가 1등
        - DB 용량 산정
        - 트랜잭션의 유형 파악 -> 테이블 수직 분할 할 때(반정규화)
        - 용량과 트랜잭션의 유형에 따라 반정규화
        - 이력모델 조정, PK / FK 조정, 슈퍼타입 / 서브타입 조정
        - 성능관점에서 데이터 모델을 검증

## 정규화
### 정규화란 ?
- : 엔티티를 작은 단위로 분리하는 과정
    
    -> 큰 엔티티를 작은 엔티티들로 분리하고 관계 맺음
- : 논리 데이터 모델에서 행하는 과정이다. (개념 모델링 X, 물리 모델링 X)

### 정규화의 특징 및 하는 이유와 개념 = 장점

- 데이터의 무결성을 위해 수행
- 최소한의 데이터만을 하나의 엔티티에 넣는 과정, 데이터 분해 과정
- 데이터 일관성 확보
- 데이터 독립성 확보 -> 데이터 중복 제거
- 데이터 유연성 확보 -> 필요 데이터들의 분할로 인해 유연하게 접근 가능
- 입력, 수정, 삭제 성능은 일반적으로 향상
    - -> 조회 성능이 저하 될 수 있음

### 정규화의 단점
- 엔티티 갯수 증가
- 이로 인한 관계 증가
- 데이터 조회시 여러 번의 조인이 요구
- 조회 성능의 저하
    - 식별자, 비식별자랑 헷갈리지 말자 -> 식별자 = join 최소화

## 정규화의 종류
    - 각 정규화를 통해 이루어지는 행위가 있는데
    - 이 행위를 만족하는 엔티티 구조는
    - 제 1 정규형 릴레이션
    - 제 2 정규형 릴레이션
    - 제 3 정규형 릴레이션 이라고 칭한다.

### 제 1 정규화
- 테이블 칼럼들이 원자성(특성의 중복을 방지) 갖게 하기 위해 엔티티 분해
    -> 하나의 인스턴스가 비슷한 속성을 여러 개 가지지 않게 하기 위해 분리하는 것

<img width="558" alt="스크린샷 2024-08-10 오후 1 56 22" src="https://github.com/user-attachments/assets/67c779b7-52ee-408c-a29b-120f350e1feb">


### 제 2 정규화
- 엔티티의 모든 일반 속성은 반드시 주 식별자의 모든 속성들에 '부분 종속'이 아닌 '완전 종속'을 가져야한다.
이때 만약 '부분 종속'을 가지는 일반 속성이 있다면 해당 속성과 해당 속성의 결정자인 부분 종속을 이루고 있는 주식별자의 속성을 따로 떼어내 추가적인 엔티티를 만들어 제 2 정규형을 만족하는 릴레이션을 구축하는 것

- 또는 주 식별자의 속성이 아닌 일반 속성 끼리 종속 관계를 맺어도 이에 대해 해당 일반 속성이 새로운 엔티티에서 제 2 정규성을 만족하도록 엔티티를 추가적으로 만들어준다.

- ex) 엔티티 1에서 일반속성 A -> 일반속성 B 이면
- 일반속성 B는 엔티티 1에서 제거하고 A는 엔티티 1에 남겨둔 채로
엔티티 2를 만들고 일반속성 B를 엔티티 2의 일반속성으로 엔티티 1의 일반속성 A를 FK로 사용하여 엔티티 2의 주식별자로서 엔티티를 구축하고 릴레이션을 유지하게 하는 것


### 제 3 정규화
- 정규화된 엔티티의 일반 속성들의 주식별자에만 함수적 종속을 가져야한다.
그런데 만약 주식별자의 속성들끼리 종속 관계를 가지고 그 이후에 또 일반속성에 대해 결정자가 되던지 일반속성끼리 종속성을 가지는데 이 때의 결정자가 주식별자 속성에 종속되어있는 등
A -> B, B -> C와 같은 '이행적 종속'을 이루는 TABLE(엔티티)일 때
이러한 '이행적 종속'을 꺠도록 추가적인 엔티티를 만들고 관계를 형성해주는 것이
제 3 정규화이다.
- BCNF 정규화
    - 모든 결정자가 후보키가 되도록 테이블을 분해하는 것
    - -> 후보키 : 식별자의 '유일성', '최소성'을 만족하는 집합(or 단일 속성)
- 제 4 정규화
    - 여러 칼럼이 하나의 칼럼 종속시킬 때 분해해서 '다중값 종속성' 제거
- 제 5 정규화
    - 조인에 의해 새로운 종속성 발생 시 이를 막기 위해 엔티티 재분해

## 반정규화
### 반정규화란 ? 특징과 하는 이유
- '정규화 된' 데이터 모델(엔티티, 속성, 관계)에 대해 '성능 향상', '개발, 운영의 단순화'를 위해 데이터를 중복, 통합, 분리하는 기법
- 정규화 시 엔티티 갯수 증가, 관계 증가 -> 여러 조인 요구
    - -> 이런 경우 디스크 I/O 양이 많아져 성능이 저하되거나 경로가 멀어서 '조인'으로 인한 성능 저하가 예상
    - -> 비정규화 = 정규화를 하지 않음, 반정규화 = 위를 하는 것

#### 반정규화의 특징
- 조회(SELECT)속도 향상
- 데이터 모델의 유연성을 저하
- -> 입력 / 수정/ 삭제 성능 저하

#### 반정규화 하는 경우
- 정규화를 통해 엔티티, 관계 수가 많아져서 조회 시 '조인'으로 인한 성능 저하 예상될 때
- 칼럼을 계산하고, 읽을 때 FK라서 여러 조인을 또 불러와서 성능이 저하 될 때
- -> 즉 조인으로 인한 I/O 양이 너무 많아져서 처리 성능이 저하 될 때
- -> 중복성을 증가시켜 조회 성능을 향상시킨다.

#### 반정규화 안하면 발생하는 문제
- 성능 저하된 DB 생성
- 구축, 시험 단계에서 수정에 따른 노력 비용 발생

## 테이블을 가지고 반정규화 방법(병합, 분할, 추가)
#### 테이블 병합
- 1:1 관계 테이블 병합
- 1:M 관계 테이블 병합
- 슈퍼 서브 타입 테이블 병합
    - -> 공통 속성과 개별 속성을 별도로 관리하는 설계 타입
#### 테이블 분할
- 테이블 수직 분할(속성 분할)
    - 트랜잭션 처리 유형 파악이 필요 -> 반정규화에서 테이블 수직 분할 할 때 필요
    - -> 테이블 속성 개수 많을 때, 조회 성능 향상을 위해
    - -> 자주 쓰이는 속성을 수직 분할 -> 이후 1:1 관계 이루게 된다.
- 테이블 수평 분할(인스턴스 분할, 파티셔닝)
    - 물리적으로 데이터 분리

#### 테이블 추가
- 중복 테이블 추가
    - 동일한 테이블 구조 중복, 원격 조인 제거
- 통계 테이블 추가
    - SUM, AVG 등 전용 테이블 추가
- 이력 테이블 추가
    - 마스터 테이블의 레코드를 긁어서 테이블 추가 생성
- 부분 테이블 추가
    - 이용 빈도 높은 칼럼을 복사하여 별도 테이블 생성, 물리적 디스크 I/O 줄이기 위해

## 칼럼을 통해 반정규화 하는 방법
- 중복 칼럼 추가 -> 중복 추가는 다 JOIN 감소 시키기 위해(중복 테이블 추가)
    - 조인 감소를 위해 중복 칼럼 추가
    - ex) 최근 상품 가격
- 파생 칼럼 추가 -> 파생 속성이 이걸 뜻하는 것 -> 부하 줄이기
    - 미리 값을 계산하여 칼럼에 보관
- 이력 테이블 칼럼 추가
    - 대량의 이력 데이터를 처리할 때 기능성 칼럼(최근값 여부, 시작 & 종료일 등)을 추가
- PK에 의한 칼럼 추가
    - 여러 칼럼으로 이루어진 PK를 가진 테이블을 조인할 경우 단순성을 위해서 인공키를 PK로 지정하고 활용
- 응용 시스템 오작동을 위한 이전 데이터 보관 칼럼 추가
    - 이전 데이터를 임시적으로 중복하여 보관

## 관계를 통해 반정규화 하는 방법
### 중복 관계 추가 방법
- 여러 경로를 거쳐 조인 할 수 있지만, 성능 저하를 예방하기 위해 추가적인 관계를 맺음
- -> 중복 관계 추가는 데이터 무결성을 깨트릴 위험성이 없음
- -> 이에 무결성을 지키면서 처리 성능을 향상 시킬 수 있음